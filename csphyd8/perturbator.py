import numpy as np
import logging
#from scipy.spatial.transform import rotation
from cspy.alpha.molecule import Molecule  # type: ignore
import quaternion

# Create logger object - Has no handler,
#       doesn't know where to send messages to.
logger = logging.getLogger('rng_logger')
logger.setLevel(logging.INFO)
# Create the relevant handlers - references to
#       output locations
fh = logging.FileHandler('perturbation.log')
fh.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.INFO)
# Add handlers to the logger:
logger.addHandler(fh)
logger.addHandler(ch)
#log_format = logging.Formatter('%(name)s - %(levelname)s - %(message)s')


def perturb_mol(mol: Molecule, ntrials: int=100,
                labels: bool=False) -> np.ndarray:
    """Pseudo-random generation of displacement and rotation perturbations
    about the origin of space.

    Parameters
    ----------
    mol: Molecule
        Cspy molecule to be perturbed.
    ntrials: int
        Number of trials to be generated by function. Should be orders of
        magnitude greater than expected number of successful insertions.
    labels: bool
        used if trial structures are to be output as .xyz files.

    Returns
    -------
    trials: (3, natoms, ntrials) ndarray
        Atomic coordinates for generated structures, maintaining atom
        ordering from input molecule object.
    radii:  (natom, ) ndarray
        Atomic radii for a single molecule, maintaining atom ordering
        from input molecule object.
    """

    bonds_dictionary = Molecule.bonds_dictionary

    def rotate(xyz, nt):
        np.random.seed(0)
        rotvecs = np.random.rand(4,nt)
        axis    = rotvecs[:3,:].T / np.linalg.norm(rotvecs[:3,:],axis=0)[:,np.newaxis]
        angle   = rotvecs[3, :] * (2*np.pi)
        rotvecs = axis * angle[:,None]
        quaternions = quaternion.from_rotation_vector(rotvecs)

        logger.info(f'dimesions prior to rotation: {xyz.shape}')
        xyz_rot = quaternion.rotate_vectors(quaternions, xyz, axis=0)
        xyz_rot = np.moveaxis(xyz_rot, 0,-1)
        logger.info(f'dimesions after rotation: {xyz_rot.shape}')

        #for i in range(nt):
        #    r = Rotation.from_rotvec(rotvecs[i])
        #    xyz[:,:,i] = r.apply(xyz[:,:,i].T).T

        return xyz_rot

    def displace(xyz, nt, scale=2):
        np.random.seed(0)
        #displ = scale * rand(3,nt)
        displ = np.random.multivariate_normal([0.0,0.0,0.0], np.eye(3)*scale, nt).T
        displ = displ[:,:,None].repeat(xyz.shape[1],2)
        displ = np.swapaxes(displ,1,2)

        xyz += displ
        logger.info(f'xyz array dimensions: {xyz.shape}')

        return xyz


    xyz  = np.array(mol.flat_atom_coord_list(), dtype=np.double).T
    com  = np.sum(xyz, axis=1)/xyz.shape[1]
    xyz -= com[:,None]

    trials = xyz
    trials = rotate(trials, ntrials)
    trials = displace(trials, ntrials)

    radii = []

    for atom in mol.atoms:
        radii.append([bonds_dictionary[(atom.clean_label(), l)] for l in
                                     ["O","H","H"]])

    radii = np.array(radii, dtype=np.float)
    lab = [atom.clean_label() for atom in mol.atoms]

    if labels is False:
        return trials, radii
    else:
        return trials, radii, lab

def xyz_make(mol):
    xyz, rad, lab = perturb_mol(mol, labels=True)
    f = open('../tests/2-perturbation/trial_molecules.xyz', 'w')
    for molecule in range(xyz.shape[-1]):
        natoms = xyz.shape[1]
        f.write(str(natoms) + '\n\n')
        for atom in range(natoms):
            f.write('{}\t {:.4f} {:.4f} {:.4f}\n'.format(lab[atom], *xyz[:,atom,
                                                                        molecule]))
    f.close()

if __name__ == '__main__':

    from loaders import load_molecule

    TESTROOT = '../tests/'
    TESTNAME = '2-perturbation/'
    TESTDIR = TESTROOT + TESTNAME
    guest_file = TESTDIR + 'nh3.xyz'

    molecule = load_molecule(guest_file)
    xyz_make(molecule)

